From d1f3b32bb1298c6c68e0e6191b4ddd582a83f7d2 Mon Sep 17 00:00:00 2001
From: Khaled Mammou <kmammou@apple.com>
Date: Sat, 7 May 2022 02:15:43 +0200
Subject: [PATCH] io/obj: parse and store coordinates / normals / uv as
 integers

Draco necessarily converts floating point data to integers by
quantization. This is not necessary if the data is already integer.

To ensure lossless coding, load and store obj data as integers.
---
 src/draco/io/obj_decoder.cc | 32 ++++++++++++++++----------------
 1 file changed, 16 insertions(+), 16 deletions(-)

diff --git a/src/draco/io/obj_decoder.cc b/src/draco/io/obj_decoder.cc
index 85d90df..86be9a9 100644
--- a/src/draco/io/obj_decoder.cc
+++ b/src/draco/io/obj_decoder.cc
@@ -36,7 +36,7 @@ ObjDecoder::ObjDecoder()
       norm_att_id_(-1),
       material_att_id_(-1),
       sub_obj_att_id_(-1),
-      deduplicate_input_values_(true),
+      deduplicate_input_values_(false),
       last_material_id_(0),
       use_metadata_(false),
       mesh_files_(nullptr),
@@ -138,22 +138,22 @@ Status ObjDecoder::DecodeInternal() {
   // Add attributes if they are present in the input data.
   if (num_positions_ > 0) {
     GeometryAttribute va;
-    va.Init(GeometryAttribute::POSITION, nullptr, 3, DT_FLOAT32, false,
-            sizeof(float) * 3, 0);
+    va.Init(GeometryAttribute::POSITION, nullptr, 3, DT_INT32, false,
+            sizeof(int32_t) * 3, 0);
     pos_att_id_ = out_point_cloud_->AddAttribute(va, use_identity_mapping,
                                                  num_positions_);
   }
   if (num_tex_coords_ > 0) {
     GeometryAttribute va;
-    va.Init(GeometryAttribute::TEX_COORD, nullptr, 2, DT_FLOAT32, false,
-            sizeof(float) * 2, 0);
+    va.Init(GeometryAttribute::TEX_COORD, nullptr, 2, DT_INT32, false,
+            sizeof(int32_t) * 2, 0);
     tex_att_id_ = out_point_cloud_->AddAttribute(va, use_identity_mapping,
                                                  num_tex_coords_);
   }
   if (num_normals_ > 0) {
     GeometryAttribute va;
-    va.Init(GeometryAttribute::NORMAL, nullptr, 3, DT_FLOAT32, false,
-            sizeof(float) * 3, 0);
+    va.Init(GeometryAttribute::NORMAL, nullptr, 3, DT_INT32, false,
+            sizeof(int32_t) * 3, 0);
     norm_att_id_ =
         out_point_cloud_->AddAttribute(va, use_identity_mapping, num_normals_);
   }
@@ -316,11 +316,11 @@ bool ObjDecoder::ParseVertexPosition(Status *status) {
   buffer()->Advance(2);
   if (!counting_mode_) {
     // Parse three float numbers for vertex position coordinates.
-    float val[3];
+    int32_t val[3];
     for (int i = 0; i < 3; ++i) {
       parser::SkipWhitespace(buffer());
-      if (!parser::ParseFloat(buffer(), val + i)) {
-        *status = Status(Status::DRACO_ERROR, "Failed to parse a float number");
+      if (!parser::ParseSignedInt(buffer(), val + i)) {
+        *status = Status(Status::DRACO_ERROR, "Failed to parse a integer number");
         // The definition is processed so return true.
         return true;
       }
@@ -345,11 +345,11 @@ bool ObjDecoder::ParseNormal(Status *status) {
   buffer()->Advance(2);
   if (!counting_mode_) {
     // Parse three float numbers for the normal vector.
-    float val[3];
+    int32_t val[3];
     for (int i = 0; i < 3; ++i) {
       parser::SkipWhitespace(buffer());
-      if (!parser::ParseFloat(buffer(), val + i)) {
-        *status = Status(Status::DRACO_ERROR, "Failed to parse a float number");
+      if (!parser::ParseSignedInt(buffer(), val + i)) {
+        *status = Status(Status::DRACO_ERROR, "Failed to parse a integer number");
         // The definition is processed so return true.
         return true;
       }
@@ -374,11 +374,11 @@ bool ObjDecoder::ParseTexCoord(Status *status) {
   buffer()->Advance(2);
   if (!counting_mode_) {
     // Parse two float numbers for the texture coordinate.
-    float val[2];
+    int32_t val[2];
     for (int i = 0; i < 2; ++i) {
       parser::SkipWhitespace(buffer());
-      if (!parser::ParseFloat(buffer(), val + i)) {
-        *status = Status(Status::DRACO_ERROR, "Failed to parse a float number");
+      if (!parser::ParseSignedInt(buffer(), val + i)) {
+        *status = Status(Status::DRACO_ERROR, "Failed to parse a integer number");
         // The definition is processed so return true.
         return true;
       }
-- 
2.32.0 (Apple Git-131)

