From 1d704e8ec6247c1733b1c8e8d29ebea6eb6dd9db Mon Sep 17 00:00:00 2001
From: Julien Ricard <julien.ricard@interdigital.com>
Date: Wed, 23 Nov 2022 18:40:59 +0100
Subject: [PATCH] Update draco use position patch

---
 ...on_scheme_constrained_multi_parallelogram_decoder.h | 17 ++++++++++++++++-
 ...on_scheme_constrained_multi_parallelogram_encoder.h | 18 ++++++++++++++++++
 2 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/src/draco/compression/attributes/prediction_schemes/mesh_prediction_scheme_constrained_multi_parallelogram_decoder.h b/src/draco/compression/attributes/prediction_schemes/mesh_prediction_scheme_constrained_multi_parallelogram_decoder.h
index 994958a..8893ee7 100644
--- a/src/draco/compression/attributes/prediction_schemes/mesh_prediction_scheme_constrained_multi_parallelogram_decoder.h
+++ b/src/draco/compression/attributes/prediction_schemes/mesh_prediction_scheme_constrained_multi_parallelogram_decoder.h
@@ -73,7 +73,9 @@ class MeshPredictionSchemeConstrainedMultiParallelogramDecoder
   // the edges are processed. For better compression, the flags are stored in
   // in separate contexts based on the number of available parallelograms at a
   // given vertex.
-  std::vector<bool> is_crease_edge_[kMaxNumParallelograms];
+#if !defined( DRACO_USE_POSITION )
+ std::vector<bool> is_crease_edge_[kMaxNumParallelograms];
+#endif
   Mode selected_mode_;
 };
 
@@ -99,7 +101,9 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramDecoder<
       this->mesh_data().vertex_to_data_map();
 
   // Current position in the |is_crease_edge_| array for each context.
+#if !defined( DRACO_USE_POSITION )
   std::vector<int> is_crease_edge_pos(kMaxNumParallelograms, 0);
+#endif
 
   // Used to store predicted value for multi-parallelogram prediction.
   std::vector<DataTypeT> multi_pred_vals(num_components);
@@ -150,6 +154,14 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramDecoder<
       for (int i = 0; i < num_components; ++i) {
         multi_pred_vals[i] = 0;
       }
+#if defined( DRACO_USE_POSITION )
+	  num_used_parallelograms = num_parallelograms;
+	  for (int i = 0; i < num_parallelograms; ++i) {
+          for (int j = 0; j < num_components; ++j) {
+            multi_pred_vals[j] += pred_vals[i][j];
+          }
+	  }
+#else
       // Check which parallelograms are actually used.
       for (int i = 0; i < num_parallelograms; ++i) {
         const int context = num_parallelograms - 1;
@@ -165,6 +177,7 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramDecoder<
           }
         }
       }
+#endif
     }
     const int dst_offset = p * num_components;
     if (num_used_parallelograms == 0) {
@@ -205,6 +218,7 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramDecoder<
 #endif
 
   // Encode selected edges using separate rans bit coder for each context.
+#if !defined( DRACO_USE_POSITION )
   for (int i = 0; i < kMaxNumParallelograms; ++i) {
     uint32_t num_flags;
     if (!DecodeVarint<uint32_t>(&num_flags, buffer)) {
@@ -225,6 +239,7 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramDecoder<
       decoder.EndDecoding();
     }
   }
+#endif
   return MeshPredictionSchemeDecoder<DataTypeT, TransformT,
                                      MeshDataT>::DecodePredictionData(buffer);
 }
diff --git a/src/draco/compression/attributes/prediction_schemes/mesh_prediction_scheme_constrained_multi_parallelogram_encoder.h b/src/draco/compression/attributes/prediction_schemes/mesh_prediction_scheme_constrained_multi_parallelogram_encoder.h
index 736598b..cdaf058 100644
--- a/src/draco/compression/attributes/prediction_schemes/mesh_prediction_scheme_constrained_multi_parallelogram_encoder.h
+++ b/src/draco/compression/attributes/prediction_schemes/mesh_prediction_scheme_constrained_multi_parallelogram_encoder.h
@@ -154,7 +154,9 @@ class MeshPredictionSchemeConstrainedMultiParallelogramEncoder
   // in separate contexts based on the number of available parallelograms at a
   // given vertex.
   // TODO(draco-eng) reconsider std::vector<bool> (performance/space).
+#if !defined( DRACO_USE_POSITION )
   std::vector<bool> is_crease_edge_[kMaxNumParallelograms];
+#endif
   Mode selected_mode_;
 
   ShannonEntropyTracker entropy_tracker_;
@@ -285,9 +287,17 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramEncoder<
         in_data + src_offset, in_data + src_offset + num_components);
     best_prediction.residuals.assign(current_residuals.begin(),
                                      current_residuals.end());
+#if defined( DRACO_USE_POSITION )
+    int iStart = 1;
+    if ((num_parallelograms > 1)) iStart = num_parallelograms;
+#endif
 
     // Compute prediction error for different cases of used parallelograms.
+#if defined( DRACO_USE_POSITION )
+    for (int num_used_parallelograms = iStart;
+#else
     for (int num_used_parallelograms = 1;
+#endif
          num_used_parallelograms <= num_parallelograms;
          ++num_used_parallelograms) {
       // Mark all parallelograms as excluded.
@@ -331,7 +341,11 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramEncoder<
           // Add overhead bits to the total error.
           error.num_bits += new_overhead_bits;
         }
+#if defined( DRACO_USE_POSITION )
+        if ((best_prediction.configuration == 0) || (error < best_prediction.error)) {
+#else
         if (error < best_prediction.error) {
+#endif
           best_prediction.error = error;
           best_prediction.configuration = configuration;
           best_prediction.num_used_parallelograms = num_used_parallelograms;
@@ -356,6 +370,7 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramEncoder<
     }
     entropy_tracker_.Push(entropy_symbols_.data(), num_components);
 
+#if !defined( DRACO_USE_POSITION )
     for (int i = 0; i < num_parallelograms; ++i) {
       if ((best_prediction.configuration & (1 << i)) == 0) {
         // Parallelogram not used, mark the edge as crease.
@@ -366,6 +381,7 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramEncoder<
         is_crease_edge_[num_parallelograms - 1].push_back(false);
       }
     }
+#endif
     this->transform().ComputeCorrection(in_data + dst_offset,
                                         best_prediction.predicted_value.data(),
                                         out_corr + dst_offset);
@@ -383,6 +399,7 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramEncoder<
     DataTypeT, TransformT, MeshDataT>::EncodePredictionData(EncoderBuffer
                                                                 *buffer) {
   // Encode selected edges using separate rans bit coder for each context.
+#if !defined( DRACO_USE_POSITION )
   for (int i = 0; i < kMaxNumParallelograms; ++i) {
     // |i| is the context based on the number of available parallelograms, which
     // is always equal to |i + 1|.
@@ -405,6 +422,7 @@ bool MeshPredictionSchemeConstrainedMultiParallelogramEncoder<
       encoder.EndEncoding(buffer);
     }
   }
+#endif
   return MeshPredictionSchemeEncoder<DataTypeT, TransformT,
                                      MeshDataT>::EncodePredictionData(buffer);
 }
-- 
1.8.3.1

