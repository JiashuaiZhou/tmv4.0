# This makefile governs the processing of a vmesh job step for a single
# test point

##
# Bash is required for interpretation of shell embedded shell scripts
SHELL := bash

##
# Some default options for make
GNUMAKEFLAGS := -rR --no-print-directory

##
# Prety output unless verbose requested
quiet = $(if $(V)$(VERBOSE),,@$(if $1,$(info $1)))
quiet_GENCFG   =$(call quiet,$(quiet_txt_GENCFG))
quiet_GENGOF   =$(call quiet,$(quiet_txt_GENGOF))
quiet_SIMPLIFY =$(call quiet,$(quiet_txt_SIMPLIFY))
quiet_UVATLAS  =$(call quiet,$(quiet_txt_UVATLAS))
quiet_FITSUBDIV=$(call quiet,$(quiet_txt_FITSUBDIV$(if $(INTER),P)))
quiet_ENC      =$(call quiet,$(quiet_txt_ENC))
quiet_DEC      =$(call quiet,$(quiet_txt_DEC))
quiet_METRIC   =$(call quiet,$(quiet_txt_METRIC))
quiet_CLN      =$(call quiet,$(quiet_txt_CLN))
quiet_MD5      =$(call quiet,$(quiet_txt_MD5))
quiet_txt_GENCFG    =$(empty)  [gencfg]  $@
quiet_txt_GENGOF    =$(empty)  [gengof]  $@
quiet_txt_SIMPLIFY  =$(empty)  [decimx]  $*
quiet_txt_UVATLAS   =$(empty)  [uvatls]  $@
quiet_txt_FITSUBDIV =$(empty)  [fsbdiv]I $*
quiet_txt_FITSUBDIVP=$(empty)  [fsbdiv]P $*
quiet_txt_ENC       =$(empty)  [encode]  $@
quiet_txt_DEC       =$(empty)  [decode]  $@
quiet_txt_METRIC    =$(empty)  [metric]  $@
quiet_txt_CLEAN     =$(empty)  [clean ]  $@
quiet_txt_MD5       =$(empty)  [md5sum]  $@
verbose_stdout = $(findstring s,$V$(VERBOSE))

##
# wrappers to allow injection of a pre-command and to check the variable
# is set when used
_GENGOF = $(strip $(PRELOAD_GENGOF) $(call var_or_error,GENGOF))
_SIMPLIFY = $(strip $(PRELOAD_SIMPLIFY) $(call var_or_error,SIMPLIFY))
_UVATLAS = $(strip $(PRELOAD_UVATLAS) $(call var_or_error,UVATLAS))
_FITSUBDIV = $(strip $(PRELOAD_FITSUBDIV) $(call var_or_error,FITSUBDIV))
_VMC = $(strip $(PRELOAD_VMC) $(call var_or_error,VMC))
_MMETRIC = $(strip $(PRELOAD_MMETRIC) $(call var_or_error,MMETRIC))

##
# write output to logs (and stdout if verbose)
# delete the output error log file if it is empty
#  $1 prefix for log file
log_output = 2> "$1.err" $(if $(verbose_stdout),| tee,>) "$1.log"
remove_errlog_if_empty = [[ -s "$1.err" ]] || rm "$1.err"

##
# vpath <file> : function to search for <file> in $(VPATH).
# Expands to the full path of <file>
vpath=$(firstword $(wildcard $1 $(addsuffix /$1,$(subst :, ,$(VPATH)))))

##
# find and add configuration files
add_cfgs = $(foreach cfg,$(call vpath,$1), -c "${cfg}")

##
# are two words equal?
# 1 if equal, empty otherwise
eq  = $(if $(filter $(firstword $1),$2),1)
neq = $(if $(filter $(firstword $1),$2),,1)

##
# var_or_error: expand the variable name $1.
# An error is generated if the named variable expands to an empty string
var_or_error = $(if $(strip $($1)),$($1),$(error $@: $1 empty))

##
# mapPair: map a function $1 over pairs of elements from $2 and $3
# mapZip: map a function $1 over tuples of elmeents from arrays named by $2
mapPair = $(call mapZip,$1,$2 $3)
mapZip = $(call mapZip1,$1,1,$2,$(mapZipFn),x x)
mapZip1 = $(if $(mapZipOk),$(eval $4)$(call mapZip1,$1,$(words $5),$3,$4,$5 x))
mapZipOk = $(word $2,$($(firstword $3)))
mapZipApply = $(call $4,$1,$(words $2),$3)
mapZipFn = $$(call $$1,$(foreach arg,$2,$$(word $$2,$${${arg}}),))

##
# add $2 as a dependency of $1
define addDep
$(eval $1: $2)
endef

define addOrderDep
$(eval $1: | $2)
endef

##
# expand pattern $1 for each framenumber in the sequence
define expand_seq_frames
$(if $(and $(firstframe),$(lastframe)),$(call shell_w_error,\
	for f in {$(firstframe)..$(lastframe)} ; do printf "$1\n" $$f ; done))
endef

##
# extract a single parameter from a config file
#  $1: parameter name
#  $2: filename to open
define read_cfg_param
$(if $(wildcard $2),$(call shell_w_error, \
	IFS=":$$IFS"; \
	while read ARG VAL; do \
		[[ $$ARG != $1 ]] && continue ; \
		echo "$$VAL"; done < "$2"))
endef

# Run a shell, report any error.
# NB: Requires gnumake 4.2 to have any effect
define shell_w_error
$(shell $1)$(if $(and $(.SHELLSTATUS),$(call neq,0,$(.SHELLSTATUS))),\
	$(error Error $(.SHELLSTATUS): $1))
endef

##############################################################################
# the default target, launches all steps
.PHONY: all
all: encode decode ;

##
# avoid deleting expensive files
.SECONDARY:


##############################################################################
# if configuration file doesn't exist, skip that stage
SKIP_GENGOF :=          $(if $(call vpath,gengof.cfg),,1)
SKIP_SIMPLIFY :=        $(if $(call vpath,simplify.cfg),,1)
SKIP_UVATLAS :=         $(if $(call vpath,uvatlas.cfg),,1)
SKIP_FITSUBDIV_INTRA := $(if $(call vpath,fitsubdiv_intra.cfg),,1)
SKIP_FITSUBDIV_INTER := $(if $(call vpath,fitsubdiv_inter.cfg),,1)
SKIP_ENCODE :=          $(if $(call vpath,encoder.cfg),,1)
SKIP_DECODE :=          $(if $(call vpath,decoder.cfg),,1)

##############################################################################
# Import configuration that applies for the whole sequence.
# The settings can then be used in recipes directly
include Makefile.cfg.seqcfg
include Makefile.cfg.mmetric

# Converts a configuration file to make format
Makefile.cfg.%: %.cfg
	$(quiet_GENCFG)awk 'BEGIN { IFS=":"; OFS=" " } \
	/^#/ { next } \
	{ sub(":", " =",$$1) ; print $$0 }' \
	$< > $@
	$(quiet)echo loaded_$(*F)=1 >> $@

# list of frame numbers and frame number variables
framenums := $(call expand_seq_frames,%d)
framenumvars := $(call expand_seq_frames,FRAMENUM=%d)

##############################################################################
# gengof dependencies: find the output file name from the config file
ifneq (1,$(SKIP_GENGOF))

goffile := $(call read_cfg_param,output,$(call vpath,gengof.cfg))
.PHONY: gengof
gengof: ${goffile} ;

endif # SKIP_GENGOF

##############################################################################
# Add per-frame dependencies for simplify and uvatlas stages
ifneq (1,$(SKIP_SIMPLIFY))
include Makefile.cfg.simplify

# expand the input/outputs, parameters from Makefile.cfg.simplify
sfy_ins_input := $(call expand_seq_frames,$(input))
sfy_outs_decimated := $(call expand_seq_frames,$(decimated))
sfy_outs_reference := $(call expand_seq_frames,$(reference))
sfy_outs_mapped := $(call expand_seq_frames,$(mapped))

tgts_simplify = $(sfy_outs_decimated) $(sfy_outs_reference) $(sfy_outs_mapped)

# phony target to run only simplify stage
.PHONY: simplify
simplify: $(tgts_simplify) ;

# add per-target dependencies
$(call mapPair,addDep,sfy_outs_decimated,sfy_ins_input)
$(call mapPair,addDep,sfy_outs_reference,sfy_ins_input)
$(call mapPair,addDep,sfy_outs_mapped,sfy_ins_input)

endif # SKIP_SIMPLIFY

##############################################################################
# Add per-frame dependencies for uvatlas stages
ifneq (1,$(SKIP_UVATLAS))
include Makefile.cfg.uvatlas

# expand the input/outputs, parameters from Makefile.cfg.uvatlas
uv_inputs := $(call expand_seq_frames,$(input))
uv_outputs := $(call expand_seq_frames,$(output))

# all outputs
tgts_uvatlas = $(uv_outputs)

# phony target to run only uvatlas stage (and dependencies)
.PHONY: uvatlas
uvatlas: $(tgts_uvatlas) ;

# add per-target dependencies
$(call mapPair,addDep,uv_outputs,uv_inputs)

endif # SKIP_UVATLAS

##############################################################################
# Add per-frame dependencides for fitsubdiv intra case
ifneq (1,$(SKIP_FITSUBDIV_INTRA))
include Makefile.cfg.fitsubdiv_intra

# expand the input/outputs, parameters from Makefile.cfg.fitsubdiv_intra
ai_ins_target := $(call expand_seq_frames,$(target))
ai_ins_source := $(call expand_seq_frames,$(source))
ai_ins_mapped := $(call expand_seq_frames,$(mapped))
ai_outs_base := $(call expand_seq_frames,$(base))
ai_outs_subdiv := $(call expand_seq_frames,$(subdiv))
ai_outs_nsubdiv := $(call expand_seq_frames,$(nsubdiv))

# all outputs
tgts_fitsubdiv_intra = $(ai_outs_base) $(ai_outs_subdiv) $(ai_outs_nsubdiv)

# phony target to run only intra fitsubdiv stage (and dependencies)
.PHONY: fitsubdiv_intra
fitsubdiv_intra: $(tgts_fitsubdiv_intra);

# add dependencies
$(foreach in,target source mapped,$\
$(foreach out,base subdiv nsubdiv,$\
$(call mapPair,addDep,ai_outs_${out},ai_ins_${in})))

# generate a stem, add frame numbers and disable inter
ai_outs_stem := $(patsubst %_base.obj,%%,${ai_outs_base})
$(ai_outs_stem): INTER:=
$(call mapPair,addDep,ai_outs_stem,framenumvars)

endif # SKIP_FITSUBDIV_INTRA

##############################################################################
# Add per-frame dependencides for fitsubdiv inter case
# NB: the intercase is tied up with mode decision
# NB: do nothing if fitsubdiv_inter.cfg doesn't exist
ifneq (1,$(SKIP_FITSUBDIV_INTER))
include Makefile.cfg.fitsubdiv_inter

# expand the input/outputs, parameters from Makefile.cfg.fitsubdiv_intra
# NB: either both ins_mapped and ins_mtarget, or ins_subdiv0 are present
#       - always:      source, target
#       - w/  mapping: mtarget, mapping
#       - w/o mapping: subdiv0
# NB: don't use the config of fitsubdiv_intra if _inter is not loaded
ifeq ($(loaded_fitsubdiv_inter),1)
ld_ins_source := $(call expand_seq_frames,$(source))
ld_ins_target := $(call expand_seq_frames,$(target))
ld_ins_mtarget := $(call expand_seq_frames,$(mtarget))
ld_ins_mapped := $(call expand_seq_frames,$(mapped))
ld_ins_subdiv0 := $(call expand_seq_frames,$(subdiv0))
ld_outs_base := $(call expand_seq_frames,$(base))
ld_outs_subdiv := $(call expand_seq_frames,$(subdiv))
ld_outs_nsubdiv := $(call expand_seq_frames,$(nsubdiv))
endif

# all outputs (of subdiv), ex mode decision
tgts_fitsubdiv_inter = $(ld_outs_base) $(ld_outs_subdiv) $(ld_outs_nsubdiv)

# generate a stem, add frame numbers
ld_outs_stem := $(patsubst %_base.obj,%%,${ld_outs_base})
$(call mapPair,addDep,ld_outs_stem,framenumvars)

endif # SKIP_FITSUBDIV_INTER

##############################################################################
# Add per-frame mode decisions for fitsubdiv inter case
# NB: do nothing if fitsubdiv_inter.cfg doesn't exist
ifneq (1,$(SKIP_FITSUBDIV_INTER))
include Makefile.cfg.fitsubdiv_choose

# per-frame decision targets
tgts_fitsubdiv_decision := $(patsubst %_base.obj,%.decision,${ld_outs_base})

# phony target to run inter/intra mode decision stage (and dependencies)
# NB: fitsubdiv_inter is an alias of fitsubdiv_choose -- some frames are
#     intra-only and shouldn't be built as inter at all
.PHONY: fitsubdiv_choose fitsubdiv_inter
fitsubdiv_choose: $(tgts_fitsubdiv_decision) ;
fitsubdiv_inter: fitsubdiv_choose ;

# the target-specific variable PREV is the decision file of the previous frame
# NB: first frame doesn't depend on any previous frame
# NB: a frame must only examine PREV if when INTER=1 (target-specific)
ld_prev_decisions := PREV= $(addprefix PREV=,$(tgts_fitsubdiv_decision))
$(call mapPair,addDep,ld_outs_stem,ld_prev_decisions)

# import the gof structure
#  - ld_frames_ref is the per-frame reference frame (before mode decision)
#  - ld_frames_gof is the per-frame gof number
# NB: don't make the dependncy if there is no goffile
# NB: wait for fitsubdiv_inter config to know how to build the gof
ifneq (,${goffile})
ifeq (1,$(loaded_fitsubdiv_inter))
include Makefile.deps.gof
endif
endif

Makefile.deps.gof: ${goffile}
ifneq (,${ld_ins_mtarget})
# for fitsubdiv_with_mapping = 1
	$(quiet_GENCFG)echo "ld_frames_ref :=" $$(cut -d' ' -f2 $(call var_or_error,<))  > $@
	$(quiet)$(    )echo "ld_frames_gof :=" $$(cut -d' ' -f3 $(call var_or_error,<)) >> $@
else
# for fitsubdiv_with_mapping = 0
#  - applies when mtarget not specified
#  - first frame in each gof is intra coded
#  - each subsequent frame in the gof is predicted from the previous
	$(quiet_GENCFG)echo "ld_frames_ref :=" $$(awk \
		'{ if ((NR - 1) % 32) print prev; else print $$1; prev = $$1 }' \
		< $(call var_or_error,<) ) > $@
	$(quiet)$(    )echo "ld_frames_gof :=" $$(cut -d' ' -f3 $(call var_or_error,<)) >> $@
endif

# mode decisions require the ai psnr, and inter frames the ld psnr
addDepIfInter = $(if $(call neq,$3,$4),$(addDep))
ai_outs_subdiv_psnr := $(addsuffix .mmetric.csv,$(ai_outs_subdiv))
ld_outs_subdiv_psnr := $(addsuffix .mmetric.csv,$(ld_outs_subdiv))
$(call mapZip,addDepIfInter,\
	tgts_fitsubdiv_decision ai_outs_subdiv_psnr framenums ld_frames_ref)
$(call mapZip,addDepIfInter,\
	tgts_fitsubdiv_decision ld_outs_subdiv_psnr framenums ld_frames_ref)

# intra decision-dependent frames (for copying)
$(call mapPair,addDep,tgts_fitsubdiv_decision,ai_outs_base)
$(call mapPair,addDep,tgts_fitsubdiv_decision,ai_outs_subdiv)
$(call mapPair,addDep,tgts_fitsubdiv_decision,ai_outs_nsubdiv)

# set the GOF & RFNUM for each inter frame
ld_frames_gof := $(addprefix GOF=,$(ld_frames_gof))
ld_frames_ref := $(addprefix RFNUM=,$(ld_frames_ref))
$(call mapPair,addDep,ld_outs_stem,ld_frames_gof)
$(call mapPair,addDep,ld_outs_stem,ld_frames_ref)

# generation of the final gof structure, if defined
ifneq (,${ld-gof})
$(ld-gof): $(tgts_fitsubdiv_decision)
fitsubdiv_choose: $(ld-gof)
endif

endif # SKIP_FITSUBDIV_INTER

##############################################################################
# Add per-frame dependencides for encoding
ifneq (1,$(SKIP_ENCODE))
include Makefile.cfg.encoder

enc_out_compressed := $(compressed)
enc_in_base := $(call expand_seq_frames,$(base))
enc_in_subdiv := $(call expand_seq_frames,$(subdiv))

tgts_encode = $(enc_out_compressed)

# phony target to build the encoded bitstream
.PHONY: encode
encode: $(tgts_encode) ;

ifeq ($(gofstruct),)
# intra coding: depends on the input files
$(tgts_encode): $(enc_in_base) $(enc_in_subdiv)
else
# inter coding depends on the mode decisions
$(tgts_encode): $(tgts_fitsubdiv_decision) $(gofstruct)
endif

endif # SKIP_ENCODE

##############################################################################
# Decoding
ifneq (1,$(SKIP_DECODE))

.PHONY: decode
decode: ${enc_out_compressed}.decoded.stamp
decode: ${enc_out_compressed}.decoded.ibsm_mmetric.csv
decode: ${enc_out_compressed}.decoded.pcc_mmetric.csv
decode: ;

# what the decoder will produce (objs) depends upon decoding
decobjs := $(call expand_seq_frames,${enc_out_compressed}.%04d_decoded.obj)
decpngs := $(call expand_seq_frames,${enc_out_compressed}.%04d_decoded.png)
${decobjs}: ${enc_out_compressed}.decoded.stamp
${decpngs}: ${enc_out_compressed}.decoded.stamp

# compute objsums/md5sums of all the obj/png files
decode: ${enc_out_compressed}.decoded.objsums
decode: ${enc_out_compressed}.decoded.md5sums
${enc_out_compressed}.decoded.objsums: ${enc_out_compressed}.decoded.stamp
${enc_out_compressed}.decoded.md5sums: ${enc_out_compressed}.decoded.stamp
${enc_out_compressed}.decoded.objsums: ${decobjs}
${enc_out_compressed}.decoded.md5sums: ${decpngs}

endif # SKIP_DECODE

##############################################################################
## Recipes to build individual steps

# for order-only dependencies on directory names
.SECONDEXPANSION:

# make a directory
%/.:
	$(quiet)mkdir -p "$(@D)"

##
# generating md5 sums
%.md5: %
	$(quiet_MD5)md5sum '$<' > '$@'

##
# generate a set of md5sums.  add depenencies to specific target
%.md5sums:
	$(quiet_MD5)md5sum $^ > $@

##
# generate a set of objsums.  add depenencies to specific target
%.objsums:
	$(quiet_MD5)$(call var_or_error,OBJSUM) $^ > $@

##
# generate initial GOF; runs over an entire sequence
%.gof: gengof.cfg
	$(quiet_GENGOF)$(PRELOAD)$(_GENGOF) $(call add_cfgs,gengof.cfg) \
	$(call log_output,$@)
	@$(call remove_errlog_if_empty,$@)

##
# simplify/decimate mesh
%_decimated.obj %_reference.obj %_mapped.obj: | $$(@D)/.
	$(quiet_SIMPLIFY)$(PRELOAD)$(_SIMPLIFY) $(call add_cfgs,simplify.cfg) \
		--input=$< \
		--decimated=$*_decimated.obj \
		--reference=$*_reference.obj \
		--mapped=$*_mapped.obj \
	$(call log_output,$*_simplify)
	@$(call remove_errlog_if_empty,$*_simplify)

##
# compute isochart
%_decimated_tex.obj: %_decimated.obj | $$(@D)/.
	$(quiet_UVATLAS)$(_UVATLAS) $(call add_cfgs,uvatlas.cfg) \
		--input=$< \
		--output=$@ \
	$(call log_output,$@)
	@$(call remove_errlog_if_empty,$@)

##
# fitsubdiv (intra/inter)
# NB: fitsubdiv in inter mode depends upon previous frame PREV
#   - except when mapping is disabled, and the previous frame is used
fitsubdiv_cfg = fitsubdiv_$(if $(INTER),inter,intra).cfg
ifneq (,${ld_ins_mtarget})
fitsubdiv_rnum = $(if $(INTER),--rnum=$$(cat $(call var_or_error,PREV)))
else
fitsubdiv_rnum = $(if $(INTER),--rnum=$(RFNUM))
endif

%_base.obj %_subdiv.obj %_nsubdiv.obj: $$(if $$(INTER),$$(PREV)) | $$(@D)/.
	$(quiet_FITSUBDIV)$(_FITSUBDIV) $(call add_cfgs,$(fitsubdiv_cfg)) \
		--fnum=${FRAMENUM} $(fitsubdiv_rnum) \
	$(call log_output,$*_fitsubdiv)
	@$(call remove_errlog_if_empty,$*_fitsubdiv)

##
# recipe to compare whether the difference between two mmetric d2 psnr values
# is greater than a threshold.
# NB: mmetric (at least 1.0.1) has the wrong column names
#  - haus_c2c_psnr is "mseF,PSNR (p2plane)"
mmetric_psnr_col = haus_c2c_psnr
define cmp_mmetric_psnrs_csv
awk 'BEGIN { FS=";" ; FN=0 } FNR==1 { FN++ }
	FNR==1 { for (col = 1; col < NF; col++) cols[$$col] = col }
	FNR==2 { psnr[FN] = $$cols["${mmetric_psnr_col}"] }
	xEND { print psnr[1], psnr[2] > "/dev/stderr" }
	END { if (psnr[1] - psnr[2] > ${maxAllowedD2PSNRLoss})
	        print "intra" ; else print "inter" }'
endef

# this version uses the log file, which may be more robust to column names
define cmp_mmetric_psnrs_log
awk 'BEGIN { FS=";" ; FN=0 } FNR==1 { FN++ }
	/mseF,PSNR (p2plane)/ { psnr[FN] = $$3 }
	END { print psnr[1], psnr[2] }
	END { exit psnr[1] - psnr[2] > ${maxAllowedD2PSNRLoss} }'
endef

# is a frame an inter frame according to the gof?
INTER = $(call neq,$(FRAMENUM),$(RFNUM))

# The frame in the reference buffer from the previous frame
refbuf_framenum_prev = $(shell cat $(call var_or_error,PREV))

# this implements a bug in the CfP submission whereby a mode decision that
# changes inter to intra forces the rest of the subgof to be intra too
# for fitsubdiv_with_mapping=1
define bug_intra_kills_subgof
$(if ${ld_ins_mtarget},$(call eq,$(refbuf_framenum_prev),$(RFNUM)),1)
endef

# mode decision test
define inter_wins
$(and $(INTER),$(bug_intra_kills_subgof),\
    $(findstring inter,\
    $(call shell_w_error,$(cmp_mmetric_psnrs_csv) $(filter %.csv,$^))))
endef

# todo? archive existing files about to be overwritten
#  ifeq ($(KEEP_INTER_SUBDIV_AFTER_INTRA_DECISION),1)
#  endif

# what to do if intra wins
#  - current frame replaces reference fame buffer content
#  - overwrite the inter objects with the winning intra ones
define recipe_intra_wins
@echo '  [decide]I' $@ intra $(FRAMENUM)
$(quiet)cp $(filter %.obj,$^) $(*D)
@touch $*_subdiv.obj.mmetric.csv
$(quiet)echo $(FRAMENUM) > $@
endef

# what to do if inter wins
#  - predict from whatever is in the reference buffer
define recipe_inter_wins
@$(    )echo '  [decide]P' $@ inter $(refbuf_framenum_prev)
$(quiet)echo $(refbuf_framenum_prev) > $@
endef

%.decision: | $$(@D)/.
	$(if $(inter_wins),$(recipe_inter_wins),$(recipe_intra_wins))

##
# generate the gof from the decisions.
# replaces 2nd column of the original gof file
ifneq (,${ld-gof})
catall = for f in $1 ; do cat $$f ; done
$(ld-gof): | $$(@D)/. ${goffile}
	$(quiet_GENGOF)paste -d' ' <(cut -d' ' -f 1 ${goffile}) \
	$(            )            <($(call catall,$(filter %.decision,$^))) \
	$(            )            <(cut -d' ' -f 3 ${goffile}) \
	> $@
endif

##
# encode
%.vmesh: | $$(@D)/.
	$(quiet_ENC)$(_VMC) $(call add_cfgs,encoder.cfg) \
		--recmesh=$@.%04d_encoded.obj \
		--rectex=$@.%04d_encoded.png \
		--recmat=$@.%04d_encoded.mtl \
		$(ENCFLAGS) \
	$(call log_output,$@)
	@$(call remove_errlog_if_empty,$@)

##
# decode
%.vmesh.decoded.stamp: %.vmesh
	$(quiet_DEC)$(_VMC) $(call add_cfgs,decoder.cfg) \
		--compressed=$< \
		--decmesh=$*.vmesh.%04d_decoded.obj \
		--dectex=$*.vmesh.%04d_decoded.png \
		--decmat=$*.vmesh.%04d_decoded.mtl \
		$(DECFLAGS) \
	$(call log_output,$*.vmesh.decoded)
	@$(call remove_errlog_if_empty,$*.vmesh.decoded)
	@touch $@

##
# mesh ibsm metric
%.vmesh.decoded.ibsm_mmetric.csv: %.vmesh.decoded.stamp
	$(quiet_METRIC)$(_MMETRIC) \
	sequence --firstFrame ${firstframe} --lastFrame ${lastframe} END \
	dequantize --inputModel "${srcmesh}" \
		--outputModel ID:deqRef --useFixedPoint \
		--qp ${srcgeombits} --minPos "${srcminpos}" --maxPos "${srcmaxpos}" \
		--qt ${srctexcoordbits} --minUv "0 0" --maxUv "1.0 1.0" END \
	dequantize --inputModel "$*.vmesh.%04d_decoded.obj" \
		--outputModel ID:deqDis --useFixedPoint \
		--qp ${srcgeombits} --minPos "${srcminpos}" --maxPos "${srcmaxpos}" \
		--qt ${srctexcoordbits} --minUv "0 0" --maxUv "1.0 1.0" END \
	compare --mode ibsm \
		--inputModelA ID:deqRef --inputMapA ${srctex} \
		--inputModelB ID:deqDis --inputMapB "$*.vmesh.%04d_decoded.png" \
		--outputCsv "$@" \
	$(call log_output,$@)
	@$(call remove_errlog_if_empty,$@)

##
# mesh pcc_metric
%.vmesh.decoded.pcc_mmetric.csv: %.vmesh.decoded.stamp
	$(quiet_METRIC)$(_MMETRIC) \
	$(pcc_mmetric_args) \
	$(call log_output,$@)
	@$(call remove_errlog_if_empty,$@)

%.obj.mmetric.csv: %.obj
	$(quiet_METRIC)$(_MMETRIC) \
	$(pcc_mmetric_args) \
	$(call log_output,$@)
	@$(call remove_errlog_if_empty,$@)

mm_firstframe   = $(if ${FRAMENUM},${FRAMENUM},${firstframe})
mm_lastframe    = $(if ${FRAMENUM},${FRAMENUM},${lastframe})
mm_recon_obj    = $(if ${FRAMENUM},$<,$*.vmesh.%04d_decoded.obj)
mm_recon_tex    = $(if ${FRAMENUM},$(srctex),$*.vmesh.%04d_decoded.png)
define pcc_mmetric_args
sequence --firstFrame ${mm_firstframe} --lastFrame ${mm_lastframe} END \
dequantize --inputModel "${srcmesh}" \
	--outputModel ID:deqRef --useFixedPoint --qp ${srcgeombits} \
	--minPos "${srcminpos}" \
	--maxPos "${srcmaxpos}" \
	--qt ${srctexcoordbits} --minUv "0 0" --maxUv "1.0 1.0" END \
reindex --sort oriented -i ID:deqRef -o ID:ref_reordered END \
sample --mode grid --gridSize ${gridsize} --hideProgress \
	--useNormal --useFixedPoint \
	--minPos "${srcminpos}" \
	--maxPos "${srcmaxpos}" \
	--bilinear -i ID:ref_reordered \
	-m ${srctex} -o ID:pcRef END \
dequantize --inputModel "${mm_recon_obj}" \
	--outputModel ID:deqDis --useFixedPoint --qp ${srcgeombits} \
	--minPos "${srcminpos}" \
	--maxPos "${srcmaxpos}" \
	--qt ${srctexcoordbits} --minUv "0 0" --maxUv "1.0 1.0" END \
reindex --sort oriented -i ID:deqDis -o ID:ref_reordered END \
sample --mode grid --gridSize ${gridsize} --hideProgress \
	--useNormal --useFixedPoint \
	--minPos "${srcminpos}" \
	--maxPos "${srcmaxpos}" \
	--bilinear -i ID:ref_reordered \
	-m ${mm_recon_tex}  -o ID:pcDis END \
compare --mode pcc --resolution ${srcmaxbblen} \
	--inputModelA ID:pcRef --inputModelB ID:pcDis \
	--outputCsv "$@"
endef

##
# remove files
.PHONY: clean
clean:
	$(quiet_CLN)rm $(wildcard $(goffile))
	$(quiet_CLN)rm $(wildcard $(tgts_simplify))
	$(quiet_CLN)rm $(wildcard $(tgts_uvatlas))
	$(quiet_CLN)rm $(wildcard $(tgts_fitsubdiv_intra))
	$(quiet_CLN)rm $(wildcard $(tgts_fitsubdiv_inter))
	$(quiet_CLN)rm $(wildcard $(tgts_fitsubdiv_decision) $(ld-gof))
	$(quiet_CLN)rm $(wildcard $(tgts_encode))
